package com.example.cmw2993.sudokuchapter3;import android.app.Dialog;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.util.Log;import android.view.Gravity;import android.widget.Toast;public class Game extends AppCompatActivity {    public static final String KEY_DIFFICULTY = "edu.lockhaven.sudoku.difficulty";    private static final String TAG = "Sudoku";    public static final int DIFFICULTY_CONTINUE = -1;    public static final int DIFFICULTY_EASY = 0;    public static final int DIFFICULTY_MEDIUM = 1;    public static final int DIFFICULTY_HARD = 2;    protected static final String PREF_PUZZLE = "puzzle";    private final String easyPuzzle =            "360000000004230800000004200" +                    "070460003820000014500013020" +                    "001900000007048300000000045";    private final String mediumPuzzle =            "650000070000506000014000005" +                    "007009000002314700000700800" +                    "500000630000201000030000097";    private final String hardPuzzle =            "009000000080605020501078000" +                    "000000700706040102004000000" +                    "000720903090301080000000600";        private int[] puzzleModel = new int[9*9];    private PuzzleView puzzleView;    private final int used[][][] = new int[9][9][];    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        Log.d(TAG,"onCreate");        int diff = getIntent().getIntExtra(KEY_DIFFICULTY,DIFFICULTY_EASY);        puzzleModel = getPuzzle(diff);        calculateUsedTiles();        puzzleView = new PuzzleView(this);        setContentView(puzzleView);        puzzleView.requestFocus();    }    private int[] getPuzzle(int diff) {        String puz;        switch(diff){            case DIFFICULTY_CONTINUE:                puz = getPreferences(MODE_PRIVATE).getString(PREF_PUZZLE, easyPuzzle);                break;            case DIFFICULTY_HARD:                puz =hardPuzzle;                break;            case DIFFICULTY_MEDIUM:                puz = mediumPuzzle;                break;            case DIFFICULTY_EASY:                default:                puz = easyPuzzle;                break;                    }                return fromPuzzleString(puz);    }    private int[] fromPuzzleString(String puzzle) {        int[]puz = new int[puzzle.length()];        for (int i = 0; i < puzzle.length();i++){            puz[i] = puzzle.charAt(i) -'0';        }        return puz;    }    public void showKeyBoardOrError(int x, int y) {        int tiles[] = getUsedTiles(x,y);        if (tiles.length == 9){            Toast toast = Toast.makeText(this, R.string.no_move_label, Toast.LENGTH_SHORT);            toast.setGravity(Gravity.CENTER,0,0);            toast.show();        }else{            Log.d(TAG,"showKeyboard: used = "+toPuzzleString(tiles));            Dialog v = new Keypad(this,tiles,puzzleView);            v.show();        }    }    private String toPuzzleString(int[] tiles) {        StringBuilder buf = new StringBuilder();        for (int element : tiles)            buf.append(element);            return buf.toString();    }    public boolean setTitleIfValid(int i, int j, int tile) {        int tiles[] = getUsedTiles(i,j);        if(tile !=0){            for (int t : tiles){                if(t == tile)                    return false;            }        }        setTile(i,j,tile);        calculateUsedTiles();        return true;    }    private void setTile(int i, int j, int value){        puzzleModel[i*9+j] = value;    }    private void calculateUsedTiles(){        for (int i = 0; i < 9;i++){            for (int j = 0; j < 9;j++){                used[i][j] = calculateUsedTiles(i,j);            }        }    }    private int[] calculateUsedTiles(int x, int y){        int[]c = new int[9];        //horizontal        for (int i = 0; i < 9;i++){            if (i==y)                continue;;            int t = getTile(x,i);            if (t != 0)                c[t-1] = t;        }        //vertical        for (int i = 0; i < 9;i++){            if (i == x)                continue;            int t =getTile(i,y);            if (t != 0)                c[t-1] = t;        }        //some cell block        int startx = (x/3)*3;        int starty = (y/3)*3;        for (int i = startx; i < startx+3; i++){            for (int j = starty; j< starty+3; j++){                if (i ==x && j ==y)                    continue;                int t = getTile(i,j);                if (t != 0)                    c[t-1] = t;            }        }        //compress        int nused = 0;        for (int t : c){            if (t!=0)               nused++;        }        int c1[] = new int [nused];        nused = 0;        for (int t:c){            if(t!=0)                c1[nused++]=t;        }        return c1;    }    private int getTile (int i, int j){        return puzzleModel[i*9+j];    }    public int[] getUsedTiles(int i, int j) {        return used[i][j];    }    public String getTileString(int i, int j) {        int v =getTile(i,j);        if (v==0)            return "";            else                return String.valueOf(v);        }    protected void onResume(){        super.onResume();        Music.play(this,R.raw.game);    }    @Override    protected void onPause(){        super.onPause();        Music.stop(this);    //save the current puzzel        getPreferences(MODE_PRIVATE).edit()                .putString(PREF_PUZZLE, toPuzzleString(puzzleModel)).commit();    }}