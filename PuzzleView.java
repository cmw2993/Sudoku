package com.example.cmw2993.sudokuchapter3;import android.content.Context;import android.graphics.Canvas;import android.graphics.Paint;import android.graphics.Rect;import android.os.Bundle;import android.os.Parcelable;import android.preference.PreferenceScreen;import android.support.v4.content.ContextCompat;import android.util.Log;import android.view.KeyEvent;import android.view.MotionEvent;import android.view.View;import android.view.animation.AnimationUtils;/** * Created by cmw2993 on 10/12/17. */public class PuzzleView extends View {    private static final String SELX = "selx";    private final String SELY = "sely";    private static final String VIEW_STATE = "viewstate";    private static final int ID = 42;    private static final String TAG = "Sudoku";    private final Game game;    private float width; //width of one tile    private float height; //height of one tile    private int selX; //x index of selected tile    private int selY; //y index of selected tile    private static Rect selRect = new Rect();    public PuzzleView(Context context) {        super(context);        this.game = (Game) context;        setFocusable(true);        setFocusableInTouchMode(true);        setId(ID);    }    protected Parcelable onSavedInstanceState(){        Parcelable parcel = super.onSaveInstanceState();        Bundle bundel = new Bundle();        bundel.putInt(SELX, selX);        bundel.putInt(SELY, selY);        bundel.putParcelable(VIEW_STATE, parcel);        return parcel;    }    protected void onRestoreInstanceState(Parcelable state){        Bundle bundle = (Bundle) state;        select(bundle.getInt(SELX), bundle.getInt(SELY));    super.onRestoreInstanceState(bundle.getParcelable(VIEW_STATE));    }    @Override    protected void onSizeChanged(int w, int h, int oldw, int oldh) {        width = w / 9.0f;        height = h / 9.0f;        getRect(selX, selY, selRect);        Log.d(TAG, "onSizeChange: width" + width + ", height" + height);        super.onSizeChanged(w, h, oldw, oldh);    }    public void getRect(int x, int y, Rect rect) {        rect.set((int) (x * width), (int) (y * height), (int) (x * width + width), (int) (y * height + height));    }    @Override    protected void onDraw(Canvas canvas) {        float strokeWidthMajor = 15.0f, strokeWithMinor = 5.0f;        Paint background = new Paint();        background.setColor(getResources().getColor(R.color.puzzle_background));        canvas.drawRect(0, 0, getWidth(), getHeight(), background);        //Draw the board...        Paint dark = new Paint();        dark.setColor(ContextCompat.getColor(getContext(), R.color.puzzle_dark));        Paint hilite = new Paint();        hilite.setColor(ContextCompat.getColor(getContext(), R.color.puzzle_hilite));        Paint light = new Paint();        light.setColor(ContextCompat.getColor(getContext(), R.color.puzzle_light));        //Hilight the lines        for (int i = 0; i < 9; i++) {            float strokeWidth = 0;            if (i % 3 == 0)                strokeWidth = strokeWidthMajor;            else                strokeWidth = strokeWithMinor;            hilite.setStrokeWidth(strokeWidth);            canvas.drawLine(0, i * height + strokeWidth, getWidth(), i * height + strokeWidth, hilite);            canvas.drawLine(i * width + strokeWidth, 0, i * width + strokeWidth, getHeight(), hilite);        }        //Draw the minor lines        for (int i = 0; i < 9; i++){            canvas.drawLine(0,i*height, getWidth(),i*height,light);            canvas.drawLine(0,i*height+1, getWidth(),i*height+1,hilite);            canvas.drawLine(i*width,0,i*width,getHeight(),light);            canvas.drawLine(i*width+1,0,i*width+1,getHeight(),hilite);        }        //Draw the major lines        for (int i = 0; i <9 ;i++){            if (i % 3 != 0)                continue;            canvas.drawLine(0,i*height, getWidth(),i*height,dark);            canvas.drawLine(0,i*height+1, getWidth(),i*height+1,hilite);            canvas.drawLine(i*width,0,i*width,getHeight(),dark);            canvas.drawLine(i*width+1,0,i*width+1,getHeight(),hilite);        }        Log.d(TAG,"PuzzleView: onDraw()");        //Draw the number        Paint foreground = new Paint(Paint.ANTI_ALIAS_FLAG);        foreground.setColor(ContextCompat.getColor(getContext(),R.color.puzzle_foreground));        foreground.setStyle(Paint.Style.FILL);        foreground.setTextSize(height*0.75f);        foreground.setTextScaleX(width/height);        foreground.setTextAlign(Paint.Align.CENTER);        //Draw font metrics        Paint.FontMetrics fn = foreground.getFontMetrics();        //centering in X: use alignment( and X at midpoint)        float x = width/2;        //centering in X: measure ascent/decent first        float y = height/2-(fn.ascent+fn.descent)/2;        for(int i = 0; i< 9;i++){            for (int j =0 ; j < 9;j++){                canvas.drawText(this.game.getTileString(i,j),i*width +x,j*height+y,foreground);            }        }    Context context = getContext();        //Draw the hints        //Pick a hint color        if(Prefs.getHints(context)) {                Paint hint = new Paint();                int[] palete = {                        ContextCompat.getColor(getContext(), R.color.puzzle_hint_0),                        ContextCompat.getColor(getContext(), R.color.puzzle_hint_1),                        ContextCompat.getColor(getContext(), R.color.puzzle_hint_2)                };                Rect r = new Rect();                for (int i = 0; i < 9; i++) {                    for (int j = 0; j < 9; j++) {                        int movesLeft = 9 - game.getUsedTiles(i, j).length;                        if (movesLeft < palete.length) {                            getRect(i, j, r);                            hint.setColor(palete[movesLeft]);                            canvas.drawRect(r, hint);                        }                    }                }        }        //Draw the selection        Log.d(TAG,"selRect"+selRect);        Paint selected = new Paint();        selected.setColor(ContextCompat.getColor(getContext(),R.color.puzzle_selected));        canvas.drawRect(selRect,selected);    }    @Override    public boolean onKeyDown(int keyCode, KeyEvent event) {        Log.d(TAG,"onKeyDown: keycode"+keyCode+", event"+event);        switch(keyCode){            case KeyEvent.KEYCODE_DPAD_UP:                select(selX,selY-1);                break;            case KeyEvent.KEYCODE_DPAD_DOWN:                select(selX,selY+1);            case KeyEvent.KEYCODE_DPAD_LEFT:                select(selX-1,selY);            case KeyEvent.KEYCODE_DPAD_RIGHT:                select(selX+1,selY);            case KeyEvent.KEYCODE_0:            case KeyEvent.KEYCODE_SPACE:                setSelectedTile(0);                break;            case KeyEvent.KEYCODE_1:                setSelectedTile(1);            case KeyEvent.KEYCODE_2:                setSelectedTile(2);            case KeyEvent.KEYCODE_3:                setSelectedTile(3);            case KeyEvent.KEYCODE_4:                setSelectedTile(4);            case KeyEvent.KEYCODE_5:                setSelectedTile(5);            case KeyEvent.KEYCODE_6:                setSelectedTile(6);            case KeyEvent.KEYCODE_7:                setSelectedTile(7);            case KeyEvent.KEYCODE_8:                setSelectedTile(8);            case KeyEvent.KEYCODE_9:                setSelectedTile(9);            case KeyEvent.KEYCODE_ENTER:            case KeyEvent.KEYCODE_DPAD_CENTER:                game.showKeyBoardOrError(selX,selY);                break;            default:                    return super.onKeyDown(keyCode, event);        }       return true;    }    @Override    public boolean onTouchEvent(MotionEvent event) {        if(event.getAction()!=MotionEvent.ACTION_DOWN){            return super.onTouchEvent(event);        }        select((int) (event.getX()/width),(int)(event.getY()/height));        game.showKeyBoardOrError(selX,selY);        Log.d(TAG,"onTouchEvent: x"+selX+", y ="+selY);        return true;    }    public void setSelectedTile(int tile) {        if(game.setTitleIfValid(selX,selY,tile)){            invalidate();        }else{            //Number is invalid            Log.d(TAG,"setSelectedTile: invalid"+tile);            startAnimation(AnimationUtils.loadAnimation(game, R.anim.shake));        }    }    private void select(int x, int y) {        invalidate(selRect);        selX = Math.min(Math.max(x,0),8);        selY = Math.min(Math.max(y,0),8);        getRect(selX,selY,selRect);        invalidate(selRect);    }}